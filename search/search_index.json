{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyfields \u00b6 Define fields in python classes. Easily. pyfields provides a simple and elegant way to define fields in python classes. With pyfields you explicitly define all aspects of a field (default value, type, documentation...) in a single place, and can refer to it from other places. It is designed with development freedom as primary target: code segregation . Everything is in the field, not in __init__ , not in __setattr__ . absolutely no constraints . Your class does not need to use type hints. You can use python 2 and 3.5. Your class is not modified behind your back: __init__ and __setattr__ are untouched. You do not need to decorate your class. You do not need your class to inherit from anything. This is particularly convenient for mix-in classes, and in general for users wishing to stay in control of their class design. no performance loss by default . If you use pyfields to declare fields without adding validators nor converters, instance attributes will be replaced with a native python attribute on first access, preserving the same level of performance than what you are used to. It provides many optional features that will make your object-oriented developments easier: all field declarations support type hints and docstring , optional fields can have default values but also default values factories (such as \"if no value is provided, copy this other field\" ) adding validators and converters to a field does not require you to write complex logic nor many lines of code. This makes field access obviously slower than the default native implementation but it is done field by field and not on the whole class at once, so fast native fields can coexist with slower validated ones (segregation principle). initializing fields in your constructor is very easy and highly customizable If your first reaction is \"what about attrs / dataclasses / pydantic / characteristic / traits / traitlets / autoclass / ...\", please have a look here . Installing \u00b6 > pip install pyfields Usage \u00b6 1. Defining a field \u00b6 A field is defined as a class member using the field() method. The idea (not new) is that you declare in a single place all aspects related to each field. For mandatory fields you do not need to provide any argument. For optional fields, you will typically provide a default value or a default_factory (we will see that later). For example let's create a Wall class with one mandatory height and one optional color field: from pyfields import field class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) Compliance with python < 3.6 If you use python < 3.6 you know that PEP484 type hints can not be declared as shown above. However you can provide them as type comments , or using the type_hint argument. Field vs. Python attribute \u00b6 By default when you use field() , nothing more than a \"lazy field\" is created on your class. This field will only be activated when you access it on an instance. That means that you are free to implement __init__ as you wish, or even to rely on the default object constructor to create instances: # instantiate using the default `object` constructor w = Wall () No exception here even if we did not provide any value for the mandatory field height ! Although this default behaviour can look surprising, you will find that this feature is quite handy to define mix-in classes with attributes but without constructor. See mixture for discussion. Of course if you do not like this behaviour you can very easily add a constructor . Until it is accessed for the first time, a field is visible on an instance with dir() (because its definition is inherited from the class) but not with vars() (because it has not been initialized on the object): >>> dir ( w )[ - 2 :] [ 'color' , 'height' ] >>> vars ( w ) {} As soon as you access it, a field is replaced with a standard native python attribute, visible in vars : >>> w . color # optional field: tdefault value is used 'white' >>> vars ( w ) { 'color' : 'white' } Of course mandatory fields must be initialized: >>> w . height pyfields . core . MandatoryFieldInitError : \\ Mandatory field 'height' has not been initialized yet on instance <...>. >>> w . height = 12 >>> vars ( w ) { 'color' : 'white' , 'height' : 12 } Your IDE (e.g. PyCharm) should recognize the name and type of the field, so you can already refer to it easily in other code using autocompletion: Type validation \u00b6 You can add type validation to a field by setting check_type=True . class Wall ( object ): height : int = field ( check_type = True , doc = \"Height of the wall in mm.\" ) color : str = field ( check_type = True , default = 'white' , doc = \"Color of the wall.\" ) yields >>> w = Wall () >>> w . height = 1 >>> w . height = ' 1 ' TypeError : Invalid value type provided for ' Wall.height ' . \\ Value should be of type ' int ' . Instead , received a ' str ' : ' 1 ' Compliance with python < 3.6 If you use python < 3.6 and require type validation you should not use type comments but rather use the type_hint argument in field . Indeed it is not possible for python code to access type comments without source code inspection. Value validation \u00b6 You can add value (and type) validation to a field by providing validators . pyfields relies on valid8 for validation, so the supported syntax is the same: For a single validator, either provide a <callable> or a tuple (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) . See here for details. For several validators, either provide a list or a dictionary. See here for details. For example: from mini_lambda import x from valid8.validation_lib import is_in colors = { 'white' , 'blue' , 'red' } class Wall ( object ): height : int = field ( validators = { 'should be a positive number' : x > 0 , 'should be a multiple of 100' : x % 100 == 0 }, doc = \"Height of the wall in mm.\" ) color : str = field ( validators = is_in ( colors ), default = 'white' , doc = \"Color of the wall.\" ) yields >>> w = Wall () >>> w . height = 100 >>> w . height = 1 valid8 . entry_points . ValidationError [ ValueError ]: Error validating [ < ... > . Wall . height = 1 ]. At least one validation function failed for value 1 . Successes : [ ' x > 0 ' ] / Failures : { ' x % 100 == 0 ' : ' InvalidValue: should be a multiple of 100. Returned False. ' }. >>> w . color = ' magenta ' valid8 . entry_points . ValidationError [ ValueError ]: Error validating [ < ... > . Wall . color = magenta ]. NotInAllowedValues : x in { ' blue ' , ' red ' , ' white ' } does not hold for x = magenta . Wrong value : ' magenta ' . See valid8 documentation for details about the syntax and available validation lib . In addition to the above syntax, pyfields support that you add validators to a field after creation, using the @field.validator decorator: todo Finally, for advanced validation scenarios you might with your validation callables to receive a bit of context. pyfields supports that the callables accept one, two or three arguments for this (where valid8 supports only 1): f(val) , f(obj, val) , and f(obj, field, val) . For example we can define walls where the width is a multiple of the length: todo Converters \u00b6 todo Native vs. Descriptor fields \u00b6 field() by default creates a so-called native field . This special construct is designed to be as fast as a normal python attribute after the first access, so that performance is not impacted. This high level of performance has a drawback: validation and conversion are not possible on a native field. So when you add type or value validation, or conversion, to a field, field() will automatically create a descriptor field instead of a native field. This is an object relying on the python descriptor protocol . Such objects have slower access time than native python attributes but provide convenient hooks necessary to perform validation and conversion. For experiments, you can force a field to be a descriptor by setting native=False : from pyfields import field class Foo : a = field () # a native field b = field ( native = False ) # a descriptor field We can easily see the difference (note: direct class access Foo.a is currently forbidden because of this issue ): >>> Foo . __dict__ [ 'a' ] < NativeField : <...>. Foo . a > >>> Foo . __dict__ [ 'b' ] < DescriptorField : <...>. Foo . a > And measure the difference in access time: import timeit f = Foo () def set_a (): f . a = 12 def set_b (): f . b = 12 def set_c (): f . c = 12 ta = timeit . Timer ( set_a ) . timeit () tb = timeit . Timer ( set_b ) . timeit () tc = timeit . Timer ( set_c ) . timeit () print ( \"Average time (ns) setting the field:\" ) print ( \" %0.2f (normal python) ; %0.2f (native field) ;\" \" %0.2f (descriptor field)\" % ( tc , ta , tb )) yields (results depend on your machine): Average time ( ns ) setting the field : 0 . 09 ( normal python ) ; 0 . 09 ( native field ) ; 0 . 44 ( descriptor field ) Why are native fields so fast ? Native fields are implemented as a \"non-data\" python descriptor that overrides itself on first access. So the first time the attribute is read, a small python method call extra cost is paid but the attribute is immediately replaced with a normal attribute inside the object __dict__ . That way, subsequent calls use native python attribute access without overhead. This trick was inspired by werkzeug's @cached_property . 2. Adding a constructor \u00b6 pyfields provides you with several alternatives to add a constructor to a class equipped with fields. The reason why we do not follow the Zen of python here ( \"There should be one-- and preferably only one --obvious way to do it.\" ) is to recognize that different developers may have different coding style or philosophies, and to be as much as possible agnostic in front of these. a - make_init \u00b6 make_init is the most compact way to add a constructor to a class with fields. With it you create your __init__ method in one line: from pyfields import field , make_init class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) __init__ = make_init () By default, all fields will appear in the constructor, in the order of appearance in the class and its parents, following the mro (method resolution order, the order in which python looks for a method in the hierarchy of classes). Since it is not possible for mandatory fields to appear after optional fields in the signature, all mandatory fields will appear first, and then all optional fields will follow. The easiest way to see the result is probably to look at the help on your class: >>> help ( Wall ) Help on class Wall in module < ... > : class Wall ( builtins . object ) | Wall ( height , color = 'white' ) | (...) or you can inspect the method: >>> help ( Wall . __init__ ) Help on function __init__ in module < ... > : __init__ ( self , height , color = ' white ' ) The ` __init__ ` method generated for you when you use ` make_init ` You can check that your constructor works as expected: >>> w = Wall ( 2 ) >>> vars ( w ) { 'color' : 'white' , 'height' : 2 } >>> w = Wall ( color = 'blue' , height = 12 ) >>> vars ( w ) { 'color' : 'blue' , 'height' : 12 } >>> Wall ( color = 'blue' ) TypeError : __init__ () missing 1 required positional argument : 'height' If you do not wish the generated constructor to expose all fields, you can customize it by providing an explicit ordered list of fields. For example below only height will be in the constructor: from pyfields import field , make_init class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) # only `height` will be in the constructor __init__ = make_init ( height ) The list can contain fields defined in another class, typically a parent class: from pyfields import field , make_init class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) class ColoredWall ( Wall ): color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) __init__ = make_init ( Wall . height ) Note: a pending issue prevents the above example to work, you have to use Wall.__dict__['height'] instead of Wall.height to reference the field from the other class. Finally, you can customize the created constructor by declaring a post-init method as the post_init_fun argument. This is roughly equivalent to @init_fields so we do not present it here, see documentation . b - @init_fields \u00b6 If you prefer to write an init function as usual, you can use the @init_fields decorator to augment this init function's signature with all or some fields. from pyfields import field , init_fields class Wall : height = field ( doc = \"Height of the wall in mm.\" ) # type: int color = field ( default = 'white' , doc = \"Color of the wall.\" ) # type: str @init_fields def __init__ ( self , msg = 'hello' ): \"\"\" Constructor. After initialization, some print message is done :param msg: the message details to add \"\"\" print ( \"post init ! height= %s , color= %s , msg= %s \" % ( self . height , self . color , msg )) self . non_field_attr = msg Note: as you can see in this example, you can of course create other attributes in this init function (done in the last line here with self.non_field_attr = msg ). Indeed, declaring fields in a class do not \"pollute\" the class, so you can do anything you like as usual. You can check that the resulting constructor works as expected: >>> help ( Wall ) Help on class Wall in module < ... > : class Wall ( builtins . object ) | Wall ( height , msg = 'hello' , color = 'white' ) ... >>> w = Wall ( 1 , 'hey' ) post init ! height = 1 , color = white , msg = hey >>> vars ( w ) { 'height' : 1 , 'color' : 'white' , 'non_field_attr' : 'hey' } Note on the order of arguments in the resulting __init__ signature: as you can see, msg appears between height and color in the signature. This corresponds to the Main features / benefits \u00b6 TODO See Also \u00b6 This library was inspired by: werkzeug.cached_property attrs dataclasses autoclass pydantic Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-pyfields","title":"Home"},{"location":"#pyfields","text":"Define fields in python classes. Easily. pyfields provides a simple and elegant way to define fields in python classes. With pyfields you explicitly define all aspects of a field (default value, type, documentation...) in a single place, and can refer to it from other places. It is designed with development freedom as primary target: code segregation . Everything is in the field, not in __init__ , not in __setattr__ . absolutely no constraints . Your class does not need to use type hints. You can use python 2 and 3.5. Your class is not modified behind your back: __init__ and __setattr__ are untouched. You do not need to decorate your class. You do not need your class to inherit from anything. This is particularly convenient for mix-in classes, and in general for users wishing to stay in control of their class design. no performance loss by default . If you use pyfields to declare fields without adding validators nor converters, instance attributes will be replaced with a native python attribute on first access, preserving the same level of performance than what you are used to. It provides many optional features that will make your object-oriented developments easier: all field declarations support type hints and docstring , optional fields can have default values but also default values factories (such as \"if no value is provided, copy this other field\" ) adding validators and converters to a field does not require you to write complex logic nor many lines of code. This makes field access obviously slower than the default native implementation but it is done field by field and not on the whole class at once, so fast native fields can coexist with slower validated ones (segregation principle). initializing fields in your constructor is very easy and highly customizable If your first reaction is \"what about attrs / dataclasses / pydantic / characteristic / traits / traitlets / autoclass / ...\", please have a look here .","title":"pyfields"},{"location":"#installing","text":"> pip install pyfields","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#1-defining-a-field","text":"A field is defined as a class member using the field() method. The idea (not new) is that you declare in a single place all aspects related to each field. For mandatory fields you do not need to provide any argument. For optional fields, you will typically provide a default value or a default_factory (we will see that later). For example let's create a Wall class with one mandatory height and one optional color field: from pyfields import field class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) Compliance with python < 3.6 If you use python < 3.6 you know that PEP484 type hints can not be declared as shown above. However you can provide them as type comments , or using the type_hint argument.","title":"1. Defining a field"},{"location":"#field-vs-python-attribute","text":"By default when you use field() , nothing more than a \"lazy field\" is created on your class. This field will only be activated when you access it on an instance. That means that you are free to implement __init__ as you wish, or even to rely on the default object constructor to create instances: # instantiate using the default `object` constructor w = Wall () No exception here even if we did not provide any value for the mandatory field height ! Although this default behaviour can look surprising, you will find that this feature is quite handy to define mix-in classes with attributes but without constructor. See mixture for discussion. Of course if you do not like this behaviour you can very easily add a constructor . Until it is accessed for the first time, a field is visible on an instance with dir() (because its definition is inherited from the class) but not with vars() (because it has not been initialized on the object): >>> dir ( w )[ - 2 :] [ 'color' , 'height' ] >>> vars ( w ) {} As soon as you access it, a field is replaced with a standard native python attribute, visible in vars : >>> w . color # optional field: tdefault value is used 'white' >>> vars ( w ) { 'color' : 'white' } Of course mandatory fields must be initialized: >>> w . height pyfields . core . MandatoryFieldInitError : \\ Mandatory field 'height' has not been initialized yet on instance <...>. >>> w . height = 12 >>> vars ( w ) { 'color' : 'white' , 'height' : 12 } Your IDE (e.g. PyCharm) should recognize the name and type of the field, so you can already refer to it easily in other code using autocompletion:","title":"Field vs. Python attribute"},{"location":"#type-validation","text":"You can add type validation to a field by setting check_type=True . class Wall ( object ): height : int = field ( check_type = True , doc = \"Height of the wall in mm.\" ) color : str = field ( check_type = True , default = 'white' , doc = \"Color of the wall.\" ) yields >>> w = Wall () >>> w . height = 1 >>> w . height = ' 1 ' TypeError : Invalid value type provided for ' Wall.height ' . \\ Value should be of type ' int ' . Instead , received a ' str ' : ' 1 ' Compliance with python < 3.6 If you use python < 3.6 and require type validation you should not use type comments but rather use the type_hint argument in field . Indeed it is not possible for python code to access type comments without source code inspection.","title":"Type validation"},{"location":"#value-validation","text":"You can add value (and type) validation to a field by providing validators . pyfields relies on valid8 for validation, so the supported syntax is the same: For a single validator, either provide a <callable> or a tuple (<callable>, <error_msg>) , (<callable>, <failure_type>) or (<callable>, <error_msg>, <failure_type>) . See here for details. For several validators, either provide a list or a dictionary. See here for details. For example: from mini_lambda import x from valid8.validation_lib import is_in colors = { 'white' , 'blue' , 'red' } class Wall ( object ): height : int = field ( validators = { 'should be a positive number' : x > 0 , 'should be a multiple of 100' : x % 100 == 0 }, doc = \"Height of the wall in mm.\" ) color : str = field ( validators = is_in ( colors ), default = 'white' , doc = \"Color of the wall.\" ) yields >>> w = Wall () >>> w . height = 100 >>> w . height = 1 valid8 . entry_points . ValidationError [ ValueError ]: Error validating [ < ... > . Wall . height = 1 ]. At least one validation function failed for value 1 . Successes : [ ' x > 0 ' ] / Failures : { ' x % 100 == 0 ' : ' InvalidValue: should be a multiple of 100. Returned False. ' }. >>> w . color = ' magenta ' valid8 . entry_points . ValidationError [ ValueError ]: Error validating [ < ... > . Wall . color = magenta ]. NotInAllowedValues : x in { ' blue ' , ' red ' , ' white ' } does not hold for x = magenta . Wrong value : ' magenta ' . See valid8 documentation for details about the syntax and available validation lib . In addition to the above syntax, pyfields support that you add validators to a field after creation, using the @field.validator decorator: todo Finally, for advanced validation scenarios you might with your validation callables to receive a bit of context. pyfields supports that the callables accept one, two or three arguments for this (where valid8 supports only 1): f(val) , f(obj, val) , and f(obj, field, val) . For example we can define walls where the width is a multiple of the length: todo","title":"Value validation"},{"location":"#converters","text":"todo","title":"Converters"},{"location":"#native-vs-descriptor-fields","text":"field() by default creates a so-called native field . This special construct is designed to be as fast as a normal python attribute after the first access, so that performance is not impacted. This high level of performance has a drawback: validation and conversion are not possible on a native field. So when you add type or value validation, or conversion, to a field, field() will automatically create a descriptor field instead of a native field. This is an object relying on the python descriptor protocol . Such objects have slower access time than native python attributes but provide convenient hooks necessary to perform validation and conversion. For experiments, you can force a field to be a descriptor by setting native=False : from pyfields import field class Foo : a = field () # a native field b = field ( native = False ) # a descriptor field We can easily see the difference (note: direct class access Foo.a is currently forbidden because of this issue ): >>> Foo . __dict__ [ 'a' ] < NativeField : <...>. Foo . a > >>> Foo . __dict__ [ 'b' ] < DescriptorField : <...>. Foo . a > And measure the difference in access time: import timeit f = Foo () def set_a (): f . a = 12 def set_b (): f . b = 12 def set_c (): f . c = 12 ta = timeit . Timer ( set_a ) . timeit () tb = timeit . Timer ( set_b ) . timeit () tc = timeit . Timer ( set_c ) . timeit () print ( \"Average time (ns) setting the field:\" ) print ( \" %0.2f (normal python) ; %0.2f (native field) ;\" \" %0.2f (descriptor field)\" % ( tc , ta , tb )) yields (results depend on your machine): Average time ( ns ) setting the field : 0 . 09 ( normal python ) ; 0 . 09 ( native field ) ; 0 . 44 ( descriptor field ) Why are native fields so fast ? Native fields are implemented as a \"non-data\" python descriptor that overrides itself on first access. So the first time the attribute is read, a small python method call extra cost is paid but the attribute is immediately replaced with a normal attribute inside the object __dict__ . That way, subsequent calls use native python attribute access without overhead. This trick was inspired by werkzeug's @cached_property .","title":"Native vs. Descriptor fields"},{"location":"#2-adding-a-constructor","text":"pyfields provides you with several alternatives to add a constructor to a class equipped with fields. The reason why we do not follow the Zen of python here ( \"There should be one-- and preferably only one --obvious way to do it.\" ) is to recognize that different developers may have different coding style or philosophies, and to be as much as possible agnostic in front of these.","title":"2. Adding a constructor"},{"location":"#a-make_init","text":"make_init is the most compact way to add a constructor to a class with fields. With it you create your __init__ method in one line: from pyfields import field , make_init class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) __init__ = make_init () By default, all fields will appear in the constructor, in the order of appearance in the class and its parents, following the mro (method resolution order, the order in which python looks for a method in the hierarchy of classes). Since it is not possible for mandatory fields to appear after optional fields in the signature, all mandatory fields will appear first, and then all optional fields will follow. The easiest way to see the result is probably to look at the help on your class: >>> help ( Wall ) Help on class Wall in module < ... > : class Wall ( builtins . object ) | Wall ( height , color = 'white' ) | (...) or you can inspect the method: >>> help ( Wall . __init__ ) Help on function __init__ in module < ... > : __init__ ( self , height , color = ' white ' ) The ` __init__ ` method generated for you when you use ` make_init ` You can check that your constructor works as expected: >>> w = Wall ( 2 ) >>> vars ( w ) { 'color' : 'white' , 'height' : 2 } >>> w = Wall ( color = 'blue' , height = 12 ) >>> vars ( w ) { 'color' : 'blue' , 'height' : 12 } >>> Wall ( color = 'blue' ) TypeError : __init__ () missing 1 required positional argument : 'height' If you do not wish the generated constructor to expose all fields, you can customize it by providing an explicit ordered list of fields. For example below only height will be in the constructor: from pyfields import field , make_init class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) # only `height` will be in the constructor __init__ = make_init ( height ) The list can contain fields defined in another class, typically a parent class: from pyfields import field , make_init class Wall : height : int = field ( doc = \"Height of the wall in mm.\" ) class ColoredWall ( Wall ): color : str = field ( default = 'white' , doc = \"Color of the wall.\" ) __init__ = make_init ( Wall . height ) Note: a pending issue prevents the above example to work, you have to use Wall.__dict__['height'] instead of Wall.height to reference the field from the other class. Finally, you can customize the created constructor by declaring a post-init method as the post_init_fun argument. This is roughly equivalent to @init_fields so we do not present it here, see documentation .","title":"a - make_init"},{"location":"#b-init_fields","text":"If you prefer to write an init function as usual, you can use the @init_fields decorator to augment this init function's signature with all or some fields. from pyfields import field , init_fields class Wall : height = field ( doc = \"Height of the wall in mm.\" ) # type: int color = field ( default = 'white' , doc = \"Color of the wall.\" ) # type: str @init_fields def __init__ ( self , msg = 'hello' ): \"\"\" Constructor. After initialization, some print message is done :param msg: the message details to add \"\"\" print ( \"post init ! height= %s , color= %s , msg= %s \" % ( self . height , self . color , msg )) self . non_field_attr = msg Note: as you can see in this example, you can of course create other attributes in this init function (done in the last line here with self.non_field_attr = msg ). Indeed, declaring fields in a class do not \"pollute\" the class, so you can do anything you like as usual. You can check that the resulting constructor works as expected: >>> help ( Wall ) Help on class Wall in module < ... > : class Wall ( builtins . object ) | Wall ( height , msg = 'hello' , color = 'white' ) ... >>> w = Wall ( 1 , 'hey' ) post init ! height = 1 , color = white , msg = hey >>> vars ( w ) { 'height' : 1 , 'color' : 'white' , 'non_field_attr' : 'hey' } Note on the order of arguments in the resulting __init__ signature: as you can see, msg appears between height and color in the signature. This corresponds to the","title":"b - @init_fields"},{"location":"#main-features-benefits","text":"TODO","title":"Main features / benefits"},{"location":"#see-also","text":"This library was inspired by: werkzeug.cached_property attrs dataclasses autoclass pydantic","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-pyfields","title":"Want to contribute ?"},{"location":"api_reference/","text":"API reference \u00b6 In general, help(symbol) will provide the latest up-to-date documentation. field \u00b6 def field ( type = ANY_TYPE , # type: Type[T] default = NO_DEFAULT , # type: T default_factory = None , # type: Callable[[], T] validators = None , # type: Validators doc = None , # type: str name = None , # type: str native = None # type: bool ): # type: (...) -> T Returns a class-level attribute definition. It allows developers to define an attribute without writing an __init__ method. Typically useful for mixin classes. Lazyness The field will be lazily-defined, so if you create an instance of the class, the field will not have any value until it is first read or written. Optional/Mandatory By default fields are mandatory, which means that you must set them before reading them (otherwise a MandatoryFieldInitError will be raised). You can define an optional field by providing a default value. This value will not be copied but used \"as is\" on all instances, following python's classical pattern for default values. If you wish to run specific code to instantiate the default value, you may provide a default_factory callable instead. That callable should have no mandatory argument and should return the default value. Typing Type hints for fields can be provided using the standard python typing mechanisms (type comments for python < 3.6 and class member type hints for python >= 3.6). Types declared this way will not be checked at runtime, they are just hints for the IDE. Instead, you can specify a type to declare that type should be checked. In that case the type will be validated everytime a new value is provided, and a TypeError will be raised if invalid. The corresponding type hint is automatically declared by field so your IDE will know about it, no need to use additional type hints. If you wish to specify a type hint without validating it, you should specify native=True . Documentation A docstring can be provided in doc for code readability. Example >>> from pyfields import field >>> class Foo : ... foo = field ( default = 'bar' , doc = \"This is an optional field with a default value\" ) ... foo2 = field ( default_factory = list , doc = \"This is an optional with a default value factory\" ) ... foo3 = field ( doc = \"This is a mandatory field\" ) ... >>> o = Foo () >>> o . foo # read access with default value 'bar' >>> o . foo2 # read access with default value factory [] >>> o . foo2 = 12 # write access >>> o . foo2 12 >>> o . foo3 # read access for mandatory attr without init Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... >>> o . foo3 = True >>> o . foo3 # read access for mandatory attr after init True >>> del o . foo3 # all attributes can be deleted, same behaviour than new object >>> o . foo3 Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... Limitations Old-style classes are not supported: in python 2, don't forget to inherit from object . Performance overhead field has two different ways to create your fields. One named NativeField is faster but does not permit type checking, validation, or converters; besides it does not work with classes using __slots__ . It is used by default everytime where it is possible, except if you use one of the abovementioned features. In that case a DescriptorField will transparently be created. You can force a DescriptorField to be created by setting native=False . The NativeField class implements the \"non-data\" descriptor protocol. So the first time the attribute is read, a small python method call extra cost is paid. But afterwards the attribute is replaced with a native attribute inside the object __dict__ , so subsequent calls use native access without overhead. This was inspired by werkzeug's @cached_property . Inspired by This method was inspired by @lazy_attribute (sagemath) @cached_property (werkzeug) and this post this post attrs / dataclasses Parameters type : an optional type for the field. If one is provided, the field will not be a simple (fast) field any more but will be a descriptor (slower) field. You can disable the check by forcing native=True default : a default value for the field. Providing a default makes the field \"optional\". default value is not copied on new instances, if you wish a new copy to be created you should provide a default_factory instead. Only one of default or default_factory should be provided. default_factory : a factory that will be called (without arguments) to get the default value for that field, everytime one is needed. Providing a default_factory makes the field \"optional\". Only one of default or default_factory should be provided. validators : a validation function definition, sequence of validation function definitions, or dictionary of validation function definitions. See valid8 \"simple syntax\" for details doc : documentation for the field. This is mostly for class readability purposes for now. name : in python < 3.6 this is mandatory, and should be the same name than the one used used in the class definition (typically, class Foo: <name> = field(name=<name>) ). native : a boolean a boolean that can be turned to False to force a field to be a descriptor field, or to True to force it to be a native field. Native fields are faster but can not support type and value validation not conversions or callbacks. None (default) automatically sets native=True if no validators nor type nor converters are provided ; and native=False otherwise. In general you should not set this manually except if (1) you provide type but do not wish the type to be enforced ; in which case you would set native=True . (2) your class does not have __dict__ (instead it has __slots__ ) ; in which case you would set native=False .","title":"API reference"},{"location":"api_reference/#api-reference","text":"In general, help(symbol) will provide the latest up-to-date documentation.","title":"API reference"},{"location":"api_reference/#field","text":"def field ( type = ANY_TYPE , # type: Type[T] default = NO_DEFAULT , # type: T default_factory = None , # type: Callable[[], T] validators = None , # type: Validators doc = None , # type: str name = None , # type: str native = None # type: bool ): # type: (...) -> T Returns a class-level attribute definition. It allows developers to define an attribute without writing an __init__ method. Typically useful for mixin classes. Lazyness The field will be lazily-defined, so if you create an instance of the class, the field will not have any value until it is first read or written. Optional/Mandatory By default fields are mandatory, which means that you must set them before reading them (otherwise a MandatoryFieldInitError will be raised). You can define an optional field by providing a default value. This value will not be copied but used \"as is\" on all instances, following python's classical pattern for default values. If you wish to run specific code to instantiate the default value, you may provide a default_factory callable instead. That callable should have no mandatory argument and should return the default value. Typing Type hints for fields can be provided using the standard python typing mechanisms (type comments for python < 3.6 and class member type hints for python >= 3.6). Types declared this way will not be checked at runtime, they are just hints for the IDE. Instead, you can specify a type to declare that type should be checked. In that case the type will be validated everytime a new value is provided, and a TypeError will be raised if invalid. The corresponding type hint is automatically declared by field so your IDE will know about it, no need to use additional type hints. If you wish to specify a type hint without validating it, you should specify native=True . Documentation A docstring can be provided in doc for code readability. Example >>> from pyfields import field >>> class Foo : ... foo = field ( default = 'bar' , doc = \"This is an optional field with a default value\" ) ... foo2 = field ( default_factory = list , doc = \"This is an optional with a default value factory\" ) ... foo3 = field ( doc = \"This is a mandatory field\" ) ... >>> o = Foo () >>> o . foo # read access with default value 'bar' >>> o . foo2 # read access with default value factory [] >>> o . foo2 = 12 # write access >>> o . foo2 12 >>> o . foo3 # read access for mandatory attr without init Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... >>> o . foo3 = True >>> o . foo3 # read access for mandatory attr after init True >>> del o . foo3 # all attributes can be deleted, same behaviour than new object >>> o . foo3 Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... Limitations Old-style classes are not supported: in python 2, don't forget to inherit from object . Performance overhead field has two different ways to create your fields. One named NativeField is faster but does not permit type checking, validation, or converters; besides it does not work with classes using __slots__ . It is used by default everytime where it is possible, except if you use one of the abovementioned features. In that case a DescriptorField will transparently be created. You can force a DescriptorField to be created by setting native=False . The NativeField class implements the \"non-data\" descriptor protocol. So the first time the attribute is read, a small python method call extra cost is paid. But afterwards the attribute is replaced with a native attribute inside the object __dict__ , so subsequent calls use native access without overhead. This was inspired by werkzeug's @cached_property . Inspired by This method was inspired by @lazy_attribute (sagemath) @cached_property (werkzeug) and this post this post attrs / dataclasses Parameters type : an optional type for the field. If one is provided, the field will not be a simple (fast) field any more but will be a descriptor (slower) field. You can disable the check by forcing native=True default : a default value for the field. Providing a default makes the field \"optional\". default value is not copied on new instances, if you wish a new copy to be created you should provide a default_factory instead. Only one of default or default_factory should be provided. default_factory : a factory that will be called (without arguments) to get the default value for that field, everytime one is needed. Providing a default_factory makes the field \"optional\". Only one of default or default_factory should be provided. validators : a validation function definition, sequence of validation function definitions, or dictionary of validation function definitions. See valid8 \"simple syntax\" for details doc : documentation for the field. This is mostly for class readability purposes for now. name : in python < 3.6 this is mandatory, and should be the same name than the one used used in the class definition (typically, class Foo: <name> = field(name=<name>) ). native : a boolean a boolean that can be turned to False to force a field to be a descriptor field, or to True to force it to be a native field. Native fields are faster but can not support type and value validation not conversions or callbacks. None (default) automatically sets native=True if no validators nor type nor converters are provided ; and native=False otherwise. In general you should not set this manually except if (1) you provide type but do not wish the type to be enforced ; in which case you would set native=True . (2) your class does not have __dict__ (instead it has __slots__ ) ; in which case you would set native=False .","title":"field"},{"location":"changelog/","text":"Changelog \u00b6 0.5.0 - First public version \u00b6 fields field() method to easily define class fields without necessarily defining a __init__ . \"native\" fields are created by default, or if native=True is set. A NativeField is a non-data descriptor that replaces itself automatically with a native python attribute after the first read, to get the same performance level on later access. \"descriptor\" fields are created when type or value validation is required, or if native=False is set. A DescriptorField uses the standard python descriptor protocol so that type and value can be validated on all future access without messing with the __setattr__ method. support for type_hint declaration to declare the type of a field. If validate_type provided, the descriptor will not be replaced with a native field, and the type will be checked on every value modification. A TypeError will be raised if type does not comply. Type hints are correctly defined so that IDEs can pick them. Fixes #10 support for validators relying on valid8 . Validators can receive (val) , (obj, val) or (obj, field, val) to support validation based on several fields. The only requirement is to return True or None in case of success. Fixes #3 init make_init method to create an entire __init__ method with control of which fields are injected, and with possibility to blend a post-init callback in. Fixes #14 . @init_fields decorator to auto-init fields before your __init__ method. @inject_fields decorator to easily inject fields in an init method and perform the assignment precisely when users want (for easy debugging). Fixes #13 misc __weakref__ added in all relevant classes. Fixes #21 Now using stubs #17 Fixed bug #11 . Fixed ValueError with mini-lambda < 2.2. Fixed #22 Because of a limitation in PyCharm type hints we had to remove support for class-level field access. This created #12 which will be fixed as soon as PyCharm issue is fixed. 0.1.0 - unpublished first draft \u00b6 Extracted from mixture .","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#050-first-public-version","text":"fields field() method to easily define class fields without necessarily defining a __init__ . \"native\" fields are created by default, or if native=True is set. A NativeField is a non-data descriptor that replaces itself automatically with a native python attribute after the first read, to get the same performance level on later access. \"descriptor\" fields are created when type or value validation is required, or if native=False is set. A DescriptorField uses the standard python descriptor protocol so that type and value can be validated on all future access without messing with the __setattr__ method. support for type_hint declaration to declare the type of a field. If validate_type provided, the descriptor will not be replaced with a native field, and the type will be checked on every value modification. A TypeError will be raised if type does not comply. Type hints are correctly defined so that IDEs can pick them. Fixes #10 support for validators relying on valid8 . Validators can receive (val) , (obj, val) or (obj, field, val) to support validation based on several fields. The only requirement is to return True or None in case of success. Fixes #3 init make_init method to create an entire __init__ method with control of which fields are injected, and with possibility to blend a post-init callback in. Fixes #14 . @init_fields decorator to auto-init fields before your __init__ method. @inject_fields decorator to easily inject fields in an init method and perform the assignment precisely when users want (for easy debugging). Fixes #13 misc __weakref__ added in all relevant classes. Fixes #21 Now using stubs #17 Fixed bug #11 . Fixed ValueError with mini-lambda < 2.2. Fixed #22 Because of a limitation in PyCharm type hints we had to remove support for class-level field access. This created #12 which will be fixed as soon as PyCharm issue is fixed.","title":"0.5.0 - First public version"},{"location":"changelog/#010-unpublished-first-draft","text":"Extracted from mixture .","title":"0.1.0 - unpublished first draft"},{"location":"long_description/","text":"python-pyfields \u00b6 Define fields in python classes. Easily. The documentation for users is available here: https://smarie.github.io/python-pyfields/ A readme for developers is available here: https://github.com/smarie/python-pyfields","title":"python-pyfields"},{"location":"long_description/#python-pyfields","text":"Define fields in python classes. Easily. The documentation for users is available here: https://smarie.github.io/python-pyfields/ A readme for developers is available here: https://github.com/smarie/python-pyfields","title":"python-pyfields"},{"location":"why/","text":"Why field ? \u00b6 During the few years I spent exploring the python world, I tried several times to find a \"good\" way to create classes where fields could be declared explicitly in a compact way with optional validation and conversion without call overhead without messing with the __init__ method I discovered: @property , that is a good start but adds a python call cost on access and lacks the possibility to add validation and conversion in a compact declaration. It relies on the generic python descriptors mechanism. attrs , a great way to define classes with many out-of-the-box features (representation, hashing, constructor, ...). Its philosophy is that objects should be immutable (They can be mutable, actually they are by default, but the validators are not executed on value modification as of 0.19). The way it works is by creating a \"smart\" __init__ script that contains all the logic (see here ), and possibly a smart __setattr__ if you ask for unmutable objects with frozen=True . autoclass was one of my first open-source projects in python: I tried to create a less optimized version of attrs , but at least something that would support basic use cases. The main difference with attrs is that fields are defined using the __init__ signature, instead of class attributes, and it is possible to define custom setters to perform validation, that are effectively called on value modification. I also developed at the time a validation lib valid8 ) that works with autoclass and attrs . The result has been used in industrial projects. But it is still not satisfying because relying on the __init__ signature to define the fields is not very elegant and flexible in particular in case of multiple inheritance. PEP557 dataclasses was largely inspired by and is roughly equivalent to attrs , although a few design choices differ and its scope seems more limited. This topic was left aside for a moment, until half 2019 where I thought that I had accumulated enough python expertise (with makefun , decopatch and many pytest libraries ) to have a fresh look on it. In the meantime I had discovered: traitlets which provides a quite elegant way to define typed fields and define validation, but requires the classes to inherit from HasTraits , and does not allow users to define converters. traits werkzeug's @cached_property and sagemath's @lazy_attribute , that both rely on the descriptor protocol to define class fields, but lack compacity pydantic embraces python 3.6+ type hints (that can be defined on class attributes). It is quite elegant, is compliant with dataclasses , and supports validators that can act on single or multiple fields. It requires classes to inherit from a BaseModel . It does not seem to support converters as of version 0.32, rather, some type conversion happens behind the scenes (see for example this issue ). But it looks definitely promising. I was still not satisfied by the landscape. So I wrote this alternative, maybe it can fit in some use cases.","title":"Why fields"},{"location":"why/#why-field","text":"During the few years I spent exploring the python world, I tried several times to find a \"good\" way to create classes where fields could be declared explicitly in a compact way with optional validation and conversion without call overhead without messing with the __init__ method I discovered: @property , that is a good start but adds a python call cost on access and lacks the possibility to add validation and conversion in a compact declaration. It relies on the generic python descriptors mechanism. attrs , a great way to define classes with many out-of-the-box features (representation, hashing, constructor, ...). Its philosophy is that objects should be immutable (They can be mutable, actually they are by default, but the validators are not executed on value modification as of 0.19). The way it works is by creating a \"smart\" __init__ script that contains all the logic (see here ), and possibly a smart __setattr__ if you ask for unmutable objects with frozen=True . autoclass was one of my first open-source projects in python: I tried to create a less optimized version of attrs , but at least something that would support basic use cases. The main difference with attrs is that fields are defined using the __init__ signature, instead of class attributes, and it is possible to define custom setters to perform validation, that are effectively called on value modification. I also developed at the time a validation lib valid8 ) that works with autoclass and attrs . The result has been used in industrial projects. But it is still not satisfying because relying on the __init__ signature to define the fields is not very elegant and flexible in particular in case of multiple inheritance. PEP557 dataclasses was largely inspired by and is roughly equivalent to attrs , although a few design choices differ and its scope seems more limited. This topic was left aside for a moment, until half 2019 where I thought that I had accumulated enough python expertise (with makefun , decopatch and many pytest libraries ) to have a fresh look on it. In the meantime I had discovered: traitlets which provides a quite elegant way to define typed fields and define validation, but requires the classes to inherit from HasTraits , and does not allow users to define converters. traits werkzeug's @cached_property and sagemath's @lazy_attribute , that both rely on the descriptor protocol to define class fields, but lack compacity pydantic embraces python 3.6+ type hints (that can be defined on class attributes). It is quite elegant, is compliant with dataclasses , and supports validators that can act on single or multiple fields. It requires classes to inherit from a BaseModel . It does not seem to support converters as of version 0.32, rather, some type conversion happens behind the scenes (see for example this issue ). But it looks definitely promising. I was still not satisfied by the landscape. So I wrote this alternative, maybe it can fit in some use cases.","title":"Why field ?"}]}