{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pyfields \u00b6 Define fields in python classes. Easily. pyfields provides a simple, elegant, extensible and fast way to define fields in python classes : with as little impact on the class as possible so that it can be used in any python class including mix-in classes. In particular not fiddling with __init__ nor __setattr__ , not requiring a class decorator, and nor requiring classes to inherit from a specific BaseModel or similar class, with a fast native implementation by default (same speed as usual python after the first attribute access), with support for default values , default values factories , type hints and docstring , with optional support for validation and conversion . This makes field access obviously slower than the default native implementation but it is done field by field and not on the whole class at once, so fast native fields can coexist with slower validated ones. If your first reaction is \"what about attrs/dataclasses/traitlets/autoclass/pydantic\", please have a look here . Installing \u00b6 > pip install pyfields Usage \u00b6 a - basics \u00b6 TODO from pyfields import field class TweeterMixin : afraid = field ( default = False , doc = \"Status of the tweeter. When this is `True`,\" \"tweets will be less aggressive.\" ) def tweet ( self ): how = \"lightly\" if self . afraid else \"loudly\" print ( \"tweeting %s \" % how ) No performance overhead field by default returns a \"non-data\" python descriptor . So the first time the attribute is read, a small python method call extra cost is paid. But afterwards the attribute is replaced with a native attribute inside the object __dict__ , so subsequent calls use native access without overhead. This was inspired by werkzeug's @cached_property . b - advanced \u00b6 TODO Main features / benefits \u00b6 TODO See Also \u00b6 This library was inspired by: werkzeug.cached_property attrs dataclasses autoclass pydantic Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-pyfields","title":"Home"},{"location":"#pyfields","text":"Define fields in python classes. Easily. pyfields provides a simple, elegant, extensible and fast way to define fields in python classes : with as little impact on the class as possible so that it can be used in any python class including mix-in classes. In particular not fiddling with __init__ nor __setattr__ , not requiring a class decorator, and nor requiring classes to inherit from a specific BaseModel or similar class, with a fast native implementation by default (same speed as usual python after the first attribute access), with support for default values , default values factories , type hints and docstring , with optional support for validation and conversion . This makes field access obviously slower than the default native implementation but it is done field by field and not on the whole class at once, so fast native fields can coexist with slower validated ones. If your first reaction is \"what about attrs/dataclasses/traitlets/autoclass/pydantic\", please have a look here .","title":"pyfields"},{"location":"#installing","text":"> pip install pyfields","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#a-basics","text":"TODO from pyfields import field class TweeterMixin : afraid = field ( default = False , doc = \"Status of the tweeter. When this is `True`,\" \"tweets will be less aggressive.\" ) def tweet ( self ): how = \"lightly\" if self . afraid else \"loudly\" print ( \"tweeting %s \" % how ) No performance overhead field by default returns a \"non-data\" python descriptor . So the first time the attribute is read, a small python method call extra cost is paid. But afterwards the attribute is replaced with a native attribute inside the object __dict__ , so subsequent calls use native access without overhead. This was inspired by werkzeug's @cached_property .","title":"a - basics"},{"location":"#b-advanced","text":"TODO","title":"b - advanced"},{"location":"#main-features-benefits","text":"TODO","title":"Main features / benefits"},{"location":"#see-also","text":"This library was inspired by: werkzeug.cached_property attrs dataclasses autoclass pydantic","title":"See Also"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-pyfields","title":"Want to contribute ?"},{"location":"api_reference/","text":"API reference \u00b6 In general, help(symbol) will provide the latest up-to-date documentation. field \u00b6 def field ( type = ANY_TYPE , # type: Type[T] default = NO_DEFAULT , # type: T default_factory = None , # type: Callable[[], T] validators = None , # type: Validators doc = None , # type: str name = None , # type: str native = None # type: bool ): # type: (...) -> T Returns a class-level attribute definition. It allows developers to define an attribute without writing an __init__ method. Typically useful for mixin classes. Lazyness The field will be lazily-defined, so if you create an instance of the class, the field will not have any value until it is first read or written. Optional/Mandatory By default fields are mandatory, which means that you must set them before reading them (otherwise a MandatoryFieldInitError will be raised). You can define an optional field by providing a default value. This value will not be copied but used \"as is\" on all instances, following python's classical pattern for default values. If you wish to run specific code to instantiate the default value, you may provide a default_factory callable instead. That callable should have no mandatory argument and should return the default value. Typing Type hints for fields can be provided using the standard python typing mechanisms (type comments for python < 3.6 and class member type hints for python >= 3.6). Types declared this way will not be checked at runtime, they are just hints for the IDE. Instead, you can specify a type to declare that type should be checked. In that case the type will be validated everytime a new value is provided, and a TypeError will be raised if invalid. The corresponding type hint is automatically declared by field so your IDE will know about it, no need to use additional type hints. If you wish to specify a type hint without validating it, you should specify native=True . Documentation A docstring can be provided in doc for code readability. Example >>> from pyfields import field >>> class Foo : ... foo = field ( default = 'bar' , doc = \"This is an optional field with a default value\" ) ... foo2 = field ( default_factory = list , doc = \"This is an optional with a default value factory\" ) ... foo3 = field ( doc = \"This is a mandatory field\" ) ... >>> o = Foo () >>> o . foo # read access with default value 'bar' >>> o . foo2 # read access with default value factory [] >>> o . foo2 = 12 # write access >>> o . foo2 12 >>> o . foo3 # read access for mandatory attr without init Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... >>> o . foo3 = True >>> o . foo3 # read access for mandatory attr after init True >>> del o . foo3 # all attributes can be deleted, same behaviour than new object >>> o . foo3 Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... Limitations Old-style classes are not supported: in python 2, don't forget to inherit from object . Performance overhead field has two different ways to create your fields. One named NativeField is faster but does not permit type checking, validation, or converters; besides it does not work with classes using __slots__ . It is used by default everytime where it is possible, except if you use one of the abovementioned features. In that case a DescriptorField will transparently be created. You can force a DescriptorField to be created by setting native=False . The NativeField class implements the \"non-data\" descriptor protocol. So the first time the attribute is read, a small python method call extra cost is paid. But afterwards the attribute is replaced with a native attribute inside the object __dict__ , so subsequent calls use native access without overhead. This was inspired by werkzeug's @cached_property . Inspired by This method was inspired by @lazy_attribute (sagemath) @cached_property (werkzeug) and this post this post attrs / dataclasses Parameters type : an optional type for the field. If one is provided, the field will not be a simple (fast) field any more but will be a descriptor (slower) field. You can disable the check by forcing native=True default : a default value for the field. Providing a default makes the field \"optional\". default value is not copied on new instances, if you wish a new copy to be created you should provide a default_factory instead. Only one of default or default_factory should be provided. default_factory : a factory that will be called (without arguments) to get the default value for that field, everytime one is needed. Providing a default_factory makes the field \"optional\". Only one of default or default_factory should be provided. validators : a validation function definition, sequence of validation function definitions, or dictionary of validation function definitions. See valid8 \"simple syntax\" for details doc : documentation for the field. This is mostly for class readability purposes for now. name : in python < 3.6 this is mandatory, and should be the same name than the one used used in the class definition (typically, class Foo: <name> = field(name=<name>) ). native : a boolean a boolean that can be turned to False to force a field to be a descriptor field, or to True to force it to be a native field. Native fields are faster but can not support type and value validation not conversions or callbacks. None (default) automatically sets native=True if no validators nor type nor converters are provided ; and native=False otherwise. In general you should not set this manually except if (1) you provide type but do not wish the type to be enforced ; in which case you would set native=True . (2) your class does not have __dict__ (instead it has __slots__ ) ; in which case you would set native=False .","title":"API reference"},{"location":"api_reference/#api-reference","text":"In general, help(symbol) will provide the latest up-to-date documentation.","title":"API reference"},{"location":"api_reference/#field","text":"def field ( type = ANY_TYPE , # type: Type[T] default = NO_DEFAULT , # type: T default_factory = None , # type: Callable[[], T] validators = None , # type: Validators doc = None , # type: str name = None , # type: str native = None # type: bool ): # type: (...) -> T Returns a class-level attribute definition. It allows developers to define an attribute without writing an __init__ method. Typically useful for mixin classes. Lazyness The field will be lazily-defined, so if you create an instance of the class, the field will not have any value until it is first read or written. Optional/Mandatory By default fields are mandatory, which means that you must set them before reading them (otherwise a MandatoryFieldInitError will be raised). You can define an optional field by providing a default value. This value will not be copied but used \"as is\" on all instances, following python's classical pattern for default values. If you wish to run specific code to instantiate the default value, you may provide a default_factory callable instead. That callable should have no mandatory argument and should return the default value. Typing Type hints for fields can be provided using the standard python typing mechanisms (type comments for python < 3.6 and class member type hints for python >= 3.6). Types declared this way will not be checked at runtime, they are just hints for the IDE. Instead, you can specify a type to declare that type should be checked. In that case the type will be validated everytime a new value is provided, and a TypeError will be raised if invalid. The corresponding type hint is automatically declared by field so your IDE will know about it, no need to use additional type hints. If you wish to specify a type hint without validating it, you should specify native=True . Documentation A docstring can be provided in doc for code readability. Example >>> from pyfields import field >>> class Foo : ... foo = field ( default = 'bar' , doc = \"This is an optional field with a default value\" ) ... foo2 = field ( default_factory = list , doc = \"This is an optional with a default value factory\" ) ... foo3 = field ( doc = \"This is a mandatory field\" ) ... >>> o = Foo () >>> o . foo # read access with default value 'bar' >>> o . foo2 # read access with default value factory [] >>> o . foo2 = 12 # write access >>> o . foo2 12 >>> o . foo3 # read access for mandatory attr without init Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... >>> o . foo3 = True >>> o . foo3 # read access for mandatory attr after init True >>> del o . foo3 # all attributes can be deleted, same behaviour than new object >>> o . foo3 Traceback ( most recent call last ): ... pyfields . core . MandatoryFieldInitError : Mandatory field 'foo3' was not set before first access on object ... Limitations Old-style classes are not supported: in python 2, don't forget to inherit from object . Performance overhead field has two different ways to create your fields. One named NativeField is faster but does not permit type checking, validation, or converters; besides it does not work with classes using __slots__ . It is used by default everytime where it is possible, except if you use one of the abovementioned features. In that case a DescriptorField will transparently be created. You can force a DescriptorField to be created by setting native=False . The NativeField class implements the \"non-data\" descriptor protocol. So the first time the attribute is read, a small python method call extra cost is paid. But afterwards the attribute is replaced with a native attribute inside the object __dict__ , so subsequent calls use native access without overhead. This was inspired by werkzeug's @cached_property . Inspired by This method was inspired by @lazy_attribute (sagemath) @cached_property (werkzeug) and this post this post attrs / dataclasses Parameters type : an optional type for the field. If one is provided, the field will not be a simple (fast) field any more but will be a descriptor (slower) field. You can disable the check by forcing native=True default : a default value for the field. Providing a default makes the field \"optional\". default value is not copied on new instances, if you wish a new copy to be created you should provide a default_factory instead. Only one of default or default_factory should be provided. default_factory : a factory that will be called (without arguments) to get the default value for that field, everytime one is needed. Providing a default_factory makes the field \"optional\". Only one of default or default_factory should be provided. validators : a validation function definition, sequence of validation function definitions, or dictionary of validation function definitions. See valid8 \"simple syntax\" for details doc : documentation for the field. This is mostly for class readability purposes for now. name : in python < 3.6 this is mandatory, and should be the same name than the one used used in the class definition (typically, class Foo: <name> = field(name=<name>) ). native : a boolean a boolean that can be turned to False to force a field to be a descriptor field, or to True to force it to be a native field. Native fields are faster but can not support type and value validation not conversions or callbacks. None (default) automatically sets native=True if no validators nor type nor converters are provided ; and native=False otherwise. In general you should not set this manually except if (1) you provide type but do not wish the type to be enforced ; in which case you would set native=True . (2) your class does not have __dict__ (instead it has __slots__ ) ; in which case you would set native=False .","title":"field"},{"location":"changelog/","text":"Changelog \u00b6 0.2.1 - bugfix \u00b6 Fixed #4 . 0.2.0 - field improvements \u00b6 New type argument in field to declare the type of a field. If provided, the descriptor will not be replaced with a native field, and the type will be checked on every value modification. A TypeError will be raised if type does not comply. Type hints are correctly defined so that IDEs can pick them. Fixes #3 New use_descriptor argument in field to force use a descriptor instead of a native field. 0.1.0 - First public version \u00b6 Mix-in basics : field class to easily define class fields in a mixin without defining a __init__ . @apply_mixins decorator to apply mixins to a class without inheritance, by copying members (=\"monkeypatching\") Light documentation","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#021-bugfix","text":"Fixed #4 .","title":"0.2.1 - bugfix"},{"location":"changelog/#020-field-improvements","text":"New type argument in field to declare the type of a field. If provided, the descriptor will not be replaced with a native field, and the type will be checked on every value modification. A TypeError will be raised if type does not comply. Type hints are correctly defined so that IDEs can pick them. Fixes #3 New use_descriptor argument in field to force use a descriptor instead of a native field.","title":"0.2.0 - field improvements"},{"location":"changelog/#010-first-public-version","text":"Mix-in basics : field class to easily define class fields in a mixin without defining a __init__ . @apply_mixins decorator to apply mixins to a class without inheritance, by copying members (=\"monkeypatching\") Light documentation","title":"0.1.0 - First public version"},{"location":"long_description/","text":"python-pyfields \u00b6 Define fields in python classes. Easily. The documentation for users is available here: https://smarie.github.io/python-pyfields/ A readme for developers is available here: https://github.com/smarie/python-pyfields","title":"python-pyfields"},{"location":"long_description/#python-pyfields","text":"Define fields in python classes. Easily. The documentation for users is available here: https://smarie.github.io/python-pyfields/ A readme for developers is available here: https://github.com/smarie/python-pyfields","title":"python-pyfields"},{"location":"why/","text":"Why field ? \u00b6 During the few years I spent exploring the python world, I tried several times to find a \"good\" way to create classes where fields could be declared explicitly in a compact way with optional validation and conversion without call overhead without messing with the __init__ method I discovered: @property , that is a good start but adds a python call cost on access and lacks the possibility to add validation and conversion in a compact declaration. It relies on the generic python descriptors mechanism. attrs , a great way to define classes with many out-of-the-box features (representation, hashing, constructor, ...). Its philosophy is that objects should be immutable (They can be mutable, actually they are by default, but the validators are not executed on value modification as of 0.19). The way it works is by creating a \"smart\" __init__ script that contains all the logic (see here ), and possibly a smart __setattr__ if you ask for unmutable objects with frozen=True . autoclass was one of my first open-source projects in python: I tried to create a less optimized version of attrs , but at least something that would support basic use cases. The main difference with attrs is that fields are defined using the __init__ signature, instead of class attributes, and it is possible to define custom setters to perform validation, that are effectively called on value modification. I also developed at the time a validation lib valid8 ) that works with autoclass and attrs . The result has been used in industrial projects. But it is still not satisfying because relying on the __init__ signature to define the fields is not very elegant and flexible in particular in case of multiple inheritance. PEP557 dataclasses was largely inspired by and is roughly equivalent to attrs , although a few design choices differ and its scope seems more limited. This topic was left aside for a moment, until half 2019 where I thought that I had accumulated enough python expertise (with makefun , decopatch and many pytest libraries ) to have a fresh look on it. In the meantime I had discovered: traitlets which provides a quite elegant way to define typed fields and define validation, but requires the classes to inherit from HasTraits , and does not allow users to define converters. traits werkzeug's @cached_property and sagemath's @lazy_attribute , that both rely on the descriptor protocol to define class fields, but lack compacity pydantic embraces python 3.6+ type hints (that can be defined on class attributes). It is quite elegant, is compliant with dataclasses , and supports validators that can act on single or multiple fields. It requires classes to inherit from a BaseModel . It does not seem to support converters as of version 0.32, rather, some type conversion happens behind the scenes (see for example this issue ). But it looks definitely promising. I was still not satisfied by the landscape. So I wrote this alternative, maybe it can fit in some use cases.","title":"Why fields"},{"location":"why/#why-field","text":"During the few years I spent exploring the python world, I tried several times to find a \"good\" way to create classes where fields could be declared explicitly in a compact way with optional validation and conversion without call overhead without messing with the __init__ method I discovered: @property , that is a good start but adds a python call cost on access and lacks the possibility to add validation and conversion in a compact declaration. It relies on the generic python descriptors mechanism. attrs , a great way to define classes with many out-of-the-box features (representation, hashing, constructor, ...). Its philosophy is that objects should be immutable (They can be mutable, actually they are by default, but the validators are not executed on value modification as of 0.19). The way it works is by creating a \"smart\" __init__ script that contains all the logic (see here ), and possibly a smart __setattr__ if you ask for unmutable objects with frozen=True . autoclass was one of my first open-source projects in python: I tried to create a less optimized version of attrs , but at least something that would support basic use cases. The main difference with attrs is that fields are defined using the __init__ signature, instead of class attributes, and it is possible to define custom setters to perform validation, that are effectively called on value modification. I also developed at the time a validation lib valid8 ) that works with autoclass and attrs . The result has been used in industrial projects. But it is still not satisfying because relying on the __init__ signature to define the fields is not very elegant and flexible in particular in case of multiple inheritance. PEP557 dataclasses was largely inspired by and is roughly equivalent to attrs , although a few design choices differ and its scope seems more limited. This topic was left aside for a moment, until half 2019 where I thought that I had accumulated enough python expertise (with makefun , decopatch and many pytest libraries ) to have a fresh look on it. In the meantime I had discovered: traitlets which provides a quite elegant way to define typed fields and define validation, but requires the classes to inherit from HasTraits , and does not allow users to define converters. traits werkzeug's @cached_property and sagemath's @lazy_attribute , that both rely on the descriptor protocol to define class fields, but lack compacity pydantic embraces python 3.6+ type hints (that can be defined on class attributes). It is quite elegant, is compliant with dataclasses , and supports validators that can act on single or multiple fields. It requires classes to inherit from a BaseModel . It does not seem to support converters as of version 0.32, rather, some type conversion happens behind the scenes (see for example this issue ). But it looks definitely promising. I was still not satisfied by the landscape. So I wrote this alternative, maybe it can fit in some use cases.","title":"Why field ?"}]}